Because both members of this group have been writing source code for this project in C for the past several weeks, we've decided to generate C code - had we written the compiler in OCaml, maybe we would have stuck with that instead.

The structure of our code generator is similar to that of our pretty-printer: a traversal of the AST where code is printed out at each leaf; however, owing to the various differences between C and GoLite, several helper functions were necessary to include details (such as typing) omitted in GoLite but strictly necessary in C.

In general, codeprogram (called from main.c) decrements into a list of declarations, specifically of variables, types, and functions. codevardec decrements, either directly or through codevarlist, into codevar; depending on the exact nature of the variable declaration (GoLite having several such patterns of syntax), the helper functions codetype (to put the type of the variable at the front of the declaration), and dummyassignment (to allow for GoLite's assignment of a value to the newly declared variable) may be called. codeidentifierlist simply spits out the identifiers, one by one, and with requisite commas. codetypedec is not in the subset of code generation implemented for milestone 3, except for structs, which we've begun to implement.

codefuncdec, the third and final case of declaration, covers the different ways in which a function can be declared (with or without a return type and with or without parameters, and where that return type is user-defined [i.e., aliased]). In general, the appropriate type ('void' if necessary) is printed before the name of the function and a list of parameters, appropriately bracketed - because C does not support GoLite's 'short' listing of parameters (e.g., a, b int, c, d float64), codeparamlist must make sure that the appropriate type is inserted at every spot in the list). Finally, codefuncdec decrements into codeblock, where statements occur.

codeblock decrements into codestatementlist, which in turn decrements into codestatement, where control may pass either to codesimplestatement (for assignment, inc/dec statements, and the like), or to the function associated with a 'complicated' statement (for, if, switch, and the like). In the case of the empty statement, nothing is done; in the case of an assignment, self-op is treated similarly as it would be in Go, while assignments of lists are handled by dummyassignmentexp, whereby each assignment is printed on a separate line; short variable declarations are handled separately, but with the help of codetypetree to infer types; and, lastly, inc/dec and expression statements are trivial. In the case of return statements, such a statement is only printed for non-void functions; print statements are now in the subset of GoLite implemented for milestone3, thanks to the helper function 'codeprintcontent', which structures a printf statement in c with the appropriate escape (e.g., %d, %f); continue, break, and block statements are trivial; and variable/type declaration statements are handled as they would be at the top level.

Finally, if statements, switch statements, and for loops are a tad more complicated. If statements can be divided along two lines: whether they have a simple statement in their scope and whether they are if, if/else, or if/else recursive statements; each case is handled under codeif whereby the appropriate functions for conditions and blocks and recursion are called; where present, the simple statement is printed in the same scope as the if statement - while this might seem to cause a problem in that later statements outside the scope could then reference it in the case of a short variable declaration, any such program would already have failed the type checker, and so this is not a concern - it may, however, be a problem if that simple statement is an assignment or inc/dec statement - this will have to be taken care of in milestone 4. In the case of for loops, things are relatively straightforward: where present, initial/post statements as well as conditions are printed, and the block of statements is printed immediately thereafter. In switch statements, each of the four possible statements (one with a simple statement and an expression to switch over, one each with only one of those two things, and one with neither of them) is handled by codeswitch, which generates a C switch statement (or switches over true when no expression is present); as was the case with if statements, the simple statement that would be within its own scope along with the condition/expression is printed in the same scope as the switch statement itself. codeswitch calls codecaselist, which calls codecasefall to generate individual cases within each list of cases within the body of the switch statement. 

The different expressions (and addOps, mulOps, and factors) are handled nearly identically to how they'd be handled in go, with syntax for an operator changing only where C differs from Go in that regard.
