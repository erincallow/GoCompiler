While C may often be irritating to work in, both of us had implemented our individual minilang assignments using flex and bison (as we’d learned it before SableCC in class), and so we decided to use C for the group project. Should we write a compiler in the future, we might explore other languages and tools, but C was sufficient for our purposes in this project.

Beyond the theory behind compilers or the necessary steps to implement one, the single biggest thing we’ve learned in this project is the importance of periodic debugging. We had the brilliant idea of writing out our entire grammar, typing it up, and then trying to compile. Should we ever write a project more elaborate than “hello, world” in the future, both of us now know to check the code as we write it so that we don’t spend days writing and rewriting what should have been accomplished in a few hours.

In terms of design decisions, we tried to make our grammar match the Go syntax provided by the website as closely as possible. In general, ‘program’ decrements into ‘package,’ which is trivial, and a list of declarations, each of which is either a variable, type, or function declaration. The function declaration is by far the most elaborate in that it has a block (i.e., a statementList delimited by braces). Our statements are either simpleStatements (a necessary grammatical category as only certain kinds of statements are allowed in the context of if/for/switch statements), or more complicated statements.

What seems most grammatically interesting is the way we implemented expressions: in order to avoid any irritating ambiguity in terms of precedence, we established a hierarchy where expressions consist of expressions and addOps, where addOps consist of addOps and mulOps, where mulOps consist of mulOps and factors, and (finally) where factors consist of other factors or base cases (i.e., primitive types).

We originally planned to implement lists (such as identifierList, expList) with an empty case and a ‘full’ case (an element followed by a list), but the fact that certain lists require commas made this difficult: instead, for many of these lists, we gave them a base case of one element instead of none and wrote a second case without this list in the grammatical rules that called for these lists.

Implementing the tree.c, tree.h, and pretty.c were comparatively straightforward - every level of the grammatical hierarchy got its own node in tree.h, every kind of every node got its own function in tree.c, and a pretty function was created for each node that would print out the appropriate lines corresponding to the kind of the node in question. Once we fixed the parser, debugging the other files was relatively simple and consisted primarily of fixing typos in function names/calls.

Although we have a working compiler for GoLite, there were a few bits of functionality we weren’t able to implement in time: while arrays and slices are supported under ‘type,’ structs are not, nor can endusers define a new type using struct; none of the constructors for these three categories does anything more elaborate than create a type. Related to this is the fact that we allow only identifiers on the lefthand side of assignments. Finally, our prettyprinter doesn't weed out break/continue outside the appropriate context and has issues dealing with strings and 'print'/'println'. But our compiler's output seems to be compilable by it, so we label this a (qualified) success.


We hope Maggie will forgive these few omissions and accept a working GoLite compiler as a worthy sacrifice.

